#include <Windows.h>
#include <tlhelp32.h>

typedef struct _LSA_UNICODE_STRING
{
    USHORT Length;
    USHORT MaximumLength;
    PWSTR  Buffer;
} LSA_UNICODE_STRING, *PLSA_UNICODE_STRING, UNICODE_STRING, *PUNICODE_STRING;

typedef struct _LDR_DATA_TABLE_ENTRY
{
    LIST_ENTRY InLoadOrderLinks;
    LIST_ENTRY InMemoryOrderLinks;
    LIST_ENTRY InInitializationOrderLinks;
    DWORD64 DllBase;
    DWORD64 EntryPoint;
    DWORD64 SizeOfImage;
    UNICODE_STRING FullDllName;
    UNICODE_STRING BaseDllName;
    DWORD Flags;
    BYTE LoadCount;
    WORD TlsIndex;
    LIST_ENTRY HashLinks;
} LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;

typedef struct _PEB_LDR_DATA
{
    DWORD Length;
    DWORD Initialized;
    DWORD64 SsHandle;
    LIST_ENTRY InLoadOrderModuleList;
    LIST_ENTRY InMemoryOrderModuleList;
    LIST_ENTRY InInitializationOrderModuleList;
    DWORD64 EntryInProgress;
    DWORD64 ShutdownInProgress;
    DWORD64 ShutdownThreadId;
} PEB_LDR_DATA, *PPEB_LDR_DATA;

typedef struct _RTL_USER_PROCESS_PARAMETERS
{
    DWORD MaximumLength;
    DWORD Length;
    DWORD Flags;
    DWORD DebugFlags;
    DWORD64 ConsoleHandle;
    DWORD64 ConsoleFlags;
} RTL_USER_PROCESS_PARAMETERS, *PRTL_USER_PROCESS_PARAMETERS;

typedef struct _PEB
{
    BYTE Reserved1[2];
    BYTE BeingDebugged;
    BYTE Reserved2[21];
    PPEB_LDR_DATA LoaderData;
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
   DWORD64 SubSystemData;
   DWORD64 ProcessHeap;
   DWORD64 FastPebLock;
   DWORD64 AtlThunkSListPtr;
   DWORD64 IFEOKey;
   DWORD64 Reserved3;
   DWORD64 KernelCallbackTable;
} PEB, *PPEB;

extern void _wow64_Shellcode64(PVOID, PVOID, PVOID);
typedef HANDLE (*TCreateToolhelp32Snapshot)(ULONG_PTR, ULONG_PTR);
typedef ULONG_PTR (*TThread32First)(HANDLE, PTHREADENTRY32);
typedef ULONG_PTR (*TThread32Next)(HANDLE, PTHREADENTRY32);
typedef ULONG_PTR (*TSuspendThread)(HANDLE);
typedef ULONG_PTR (*TResumeThread)(HANDLE);
typedef HANDLE (*TOpenThread)(ULONG_PTR, BOOL, ULONG_PTR);
typedef ULONG_PTR (*TGetCurrentProcessId)(void);
typedef ULONG_PTR (*TGetCurrentThreadId)(void);
typedef ULONG_PTR (*TLdrLoadDll)(PWCHAR, ULONG_PTR, PUNICODE_STRING, PHANDLE);
typedef SIZE_T (*TRtlCompareMemory)(const VOID *, const VOID *, SIZE_T);
typedef VOID (*TRtlInitUnicodeString)(PUNICODE_STRING, PCWSTR);
typedef DWORD64 (*TNtProtectVirtualMemory)(HANDLE, PVOID *, PULONG_PTR, ULONG_PTR, PULONG_PTR);

static inline int _wow64_Strcmp(const char *s1, const char *s2)
{
    while (*s1 == *s2++)
    {
        if (*s1++ == '\0')
            return 0;
    }

    return 1;
}

PPEB _wow64_getPeb()
{
    PPEB peb;

    asm (".intel_syntax noprefix\n"
         "gs mov rax, QWORD PTR [0x60]\n"
         "mov %0, rax\n"
         ".att_syntax noprefix"
     :"=r"(peb) : : "%rax");

    return peb;
}

PVOID _wow64_GetFuncAddress(PBYTE moduleBase, const char *funcName)
{
    PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER) moduleBase;
    PIMAGE_NT_HEADERS ntHeader = (PIMAGE_NT_HEADERS)&moduleBase[dosHeader->e_lfanew];
    PIMAGE_DATA_DIRECTORY exports = &ntHeader->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT];
    PIMAGE_EXPORT_DIRECTORY exportDirectory = (PIMAGE_EXPORT_DIRECTORY) &moduleBase[exports->VirtualAddress];
    PWORD ordinals = (PWORD) &moduleBase[exportDirectory->AddressOfNameOrdinals];
    PDWORD names = (PDWORD) &moduleBase[exportDirectory->AddressOfNames];
    PDWORD functions = (PDWORD) &moduleBase[exportDirectory->AddressOfFunctions];

    for (int x = 0; x != exportDirectory->NumberOfFunctions; ++x)
    {
        if (_wow64_Strcmp(funcName, (const char *)&moduleBase[names[x]]) == 0)
        {
            return &moduleBase[functions[ordinals[x]]];
        }
    }

    return NULL;
}

PLDR_DATA_TABLE_ENTRY _wow64_GetNtdllLdrData(PPEB peb)
{
    PLIST_ENTRY entry = peb->LoaderData->InLoadOrderModuleList.Flink->Flink;
    return CONTAINING_RECORD(entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);
}

void _wow64_PatchNtdll(PPEB peb)
{
    ULONG_PTR size = 12 * sizeof(wchar_t);
    ULONG_PTR OldAccessProtection;
    PLDR_DATA_TABLE_ENTRY ntdll = _wow64_GetNtdllLdrData(peb);
    TRtlCompareMemory pRtlCompareMemory = _wow64_GetFuncAddress((PBYTE) ntdll->DllBase, "RtlCompareMemory");
    TNtProtectVirtualMemory pNtProtectVirtualMemory = _wow64_GetFuncAddress((PBYTE) ntdll->DllBase, "NtProtectVirtualMemory");

    for (int x = 0; x != ntdll->SizeOfImage; ++x)
    {
        if (pRtlCompareMemory(L"KERNEL32.DLL", &((PBYTE)ntdll->DllBase)[x], size) == size)
        {
            PVOID BaseAddress = &((PBYTE)ntdll->DllBase)[x];
            pNtProtectVirtualMemory((HANDLE) -1, &BaseAddress, &size, PAGE_READWRITE, &OldAccessProtection);
            ((PBYTE)ntdll->DllBase)[x] = 'a';
            pNtProtectVirtualMemory((HANDLE) -1, &BaseAddress, &size, OldAccessProtection, &OldAccessProtection);
        }
    }
}

ULONG_PTR _wow64_SuspendThreads(HANDLE ModuleHandle, HANDLE (*threads)[1024])
{
    TCreateToolhelp32Snapshot pCreateToolhelp32Snapshot = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "CreateToolhelp32Snapshot");
    TThread32First pThread32First = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "Thread32First");
    TThread32Next pThread32Next = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "Thread32Next");
    TSuspendThread pSuspendThread = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "SuspendThread");
    TOpenThread pOpenThread = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "OpenThread");
    TGetCurrentProcessId pGetCurrentProcessId = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "GetCurrentProcessId");
    TGetCurrentThreadId pGetCurrentThreadId = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "GetCurrentThreadId");
    HANDLE h = pCreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
    ULONG_PTR myPID = pGetCurrentProcessId();
    ULONG_PTR myTID = pGetCurrentThreadId();
    THREADENTRY32 te = { .dwSize = sizeof(te) };
    pThread32First(h, &te);
    ULONG_PTR threadCount = 0;

    do
    {
        if (te.th32OwnerProcessID == myPID && te.th32ThreadID != myTID)
        {
            (*threads)[threadCount] = pOpenThread(THREAD_SUSPEND_RESUME, FALSE, te.th32ThreadID);
            pSuspendThread((*threads)[threadCount]);
            ++threadCount;
        }

        te.dwSize = sizeof(te);
    } while (pThread32Next(h, &te));

    return threadCount;
}

void _wow64_ResumeThreads(HANDLE ModuleHandle, HANDLE (*threads)[1024], ULONG_PTR threadCount)
{
    TResumeThread pResumeThread = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "ResumeThread");

    while (threadCount--)
    {
        pResumeThread((*threads)[threadCount]);
    }
}

void _wow64_Start()
{
    HANDLE threads[1024];
    UNICODE_STRING ModuleFileName;
    PPEB peb = _wow64_getPeb();
    PLDR_DATA_TABLE_ENTRY ntdll = _wow64_GetNtdllLdrData(peb);
    TLdrLoadDll pLdrLoadDll = _wow64_GetFuncAddress((PBYTE) ntdll->DllBase, "LdrLoadDll");
    TRtlInitUnicodeString pRtlInitUnicodeString = _wow64_GetFuncAddress((PBYTE) ntdll->DllBase, "RtlInitUnicodeString");
    HANDLE ModuleHandle;
    _wow64_PatchNtdll(peb);
    pRtlInitUnicodeString(&ModuleFileName, L"C:\\windows\\system32\\kernel32.dll");
    peb->ProcessParameters->ConsoleHandle = -1;
    DWORD64 originalCallbackTable = peb->KernelCallbackTable;
    pLdrLoadDll(NULL, 0, &ModuleFileName, &ModuleHandle);
    ULONG_PTR threadCount = _wow64_SuspendThreads(ModuleHandle, &threads);

	void* args[2];	
	args[0] = ModuleHandle;
	args[1] = _wow64_GetFuncAddress((PBYTE) ModuleHandle, "GetProcAddress");
	_wow64_Shellcode64(args, 0, 0);
	
	
    peb->KernelCallbackTable = originalCallbackTable;
    _wow64_ResumeThreads(ModuleHandle, &threads, threadCount);
}

