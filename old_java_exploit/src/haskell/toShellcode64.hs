import Numeric
import Data.Char
import Data.List
import Data.String.Utils

preCode = [
	"[bits 64]",
	"default rel",
	"push rbp",
	"mov rbp, rsp",
	"mov r9, qword [rcx+8]",
	"mov qword [rbp], r9",
	"mov rcx, qword [rcx]",
	"lea rdx, [sLoadLibrary]",
	"sub rsp, 32",
	"call r9",
	"add rsp, 32",
	"mov rcx, rax",
	"mov rdx, qword [rbp]",
	"call Start",
	"mov rsp, rbp",
	"pop rbp",
	"ret",
	"sLoadLibrary db \"LoadLibraryA\", 0"
	]

main :: IO ()
main = interact (unlines . parse . lines)

parse :: [String] -> [String]
parse x = preCode ++ concatMap (parseLine . filter (/= "PTR") . words) x

octalmap = [ ("\", " ++ show x ++ ",\"", "\\" ++ showIntAtBase 8 intToDigit x "") | x <- [255, 254 .. 0] ]
replaceOct s = foldl (\(a, _) (x, y) -> (replace y x a, "")) (s, "") octalmap

parseLine :: [String] -> [String]
parseLine (".align":xs) = ["align 16"]
parseLine (".ascii":xs) = ["db " ++ fst (replaceOct (replace "\\\\" "\", 92, \"" (unwords xs)))]
parseLine (('.':xs):_)
	| (xs !! (length xs - 1)) /= ':' = []
	| otherwise = [ xs ]
parseLine xs = parse2 $ map fixAddressing xs

fixAddressing xs = replace "." "" (replace "+-" "-" (replace "rip+" "" f))
	where
		f
			| head xs /= '[' && any (== '[') xs = (takeWhile g (dropWhile h xs)) ++ "+" ++ takeWhile h xs ++ dropWhile g xs
			| otherwise = xs
		g = (/= ']')
		h = (/= '[')

parse2 ("call" : "[QWORD" : xs) = ["call " ++ take (length (head xs) - 1) (head xs)]
parse2 xs
	| length xs == 2 = fixShift xs
	| otherwise = [unwords xs]
		
fixShift ("shr":b:_) = [ "shr " ++ b ++ ", 1" ]
fixShift ("shl":b:_) = [ "shl " ++ b ++ ", 1" ]	
fixShift xs = [unwords xs]

