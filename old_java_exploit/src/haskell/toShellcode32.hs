import Numeric
import Data.Char
import Data.List
import Data.String.Utils

preCode = [
	"[bits 32]",
	"%macro getBase 2",
	"call %%delta",
	"%%delta:",
	"pop %1",
	"lea %1, [%1-%%delta+%2]",
	"%endmacro",	
	"%macro addBase 2",
	"pushf",
	"call %%delta",
	"%%delta:",
	"add %1, DWORD [esp]",
	"add esp, 4",
	"lea %1, [%1-%%delta+%2]",
	"popf",
	"%endmacro",
	"%macro subBase 2",
	"pushf",
	"call %%delta",
	"%%delta:",
	"sub %1, DWORD [esp]",
	"add esp, 4",
	"lea %1, [%1+%%delta-%2]",
	"popf",
	"%endmacro"
	]

main :: IO ()
main = interact (unlines . parse . lines)

parse :: [String] -> [String]
parse x = preCode ++ concatMap (parseLine . filter (/= "PTR") . words) x

octalmap = [ ("\", " ++ show x ++ ",\"", "\\" ++ showIntAtBase 8 intToDigit x "") | x <- [255, 254 .. 0] ]
replaceOct s = foldl (\(a, _) (x, y) -> (replace y x a, "")) (s, "") octalmap

parseLine :: [String] -> [String]
parseLine (".ascii":xs) = ["db " ++ fst (replaceOct (replace "\\\\" "\", 92, \"" (unwords xs)))]
parseLine (('.':_):_) = []
parseLine ("call" : "[DWORD" : xs) = ["call DWORD " ++ take (length (head xs) - 1) (head xs)]
parseLine xs
	| length xs == 2 = fixShift xs
	| length xs > 4 = f xs
	| length xs > 3 = f2 xs
	| otherwise = [unwords xs]

fixShift ("shr":b:_) = [ "shr " ++ b ++ ", 1" ]
fixShift ("shl":b:_) = [ "shl " ++ b ++ ", 1" ]	
fixShift xs = [unwords xs]

f ("mov":b:c:"OFFSET":xs) = [
	"pusha",
	"getBase eax, " ++ drop 5 (head xs),
	"mov " ++ b ++ " " ++ calcEsp c ++ " eax",
	"popa"
	]
f xs = [unwords xs]	

f2 ("mov":b:"OFFSET":xs) = [ "getBase " ++ b ++ " " ++ drop 5 (head xs) ]
f2 (a:b:c:d:_)
	| head d == '_' = g (takeWhile (/= '[') d) (takeWhile (\x -> (x /= '+') && (x /= ']')) (tail $ dropWhile (/= '[') d))
	| otherwise = [ a ++ " " ++ b ++ " " ++ c ++ " " ++ d ]
	where
		g x y = [
			"addBase " ++ y ++ ", " ++ x,
			a ++ " " ++ b ++ " " ++ c ++ " " ++ dropWhile (/= '[') d,
			"subBase " ++ y ++ ", " ++ x
			]	
f2 xs = [unwords xs]	
	
calcEsp :: String -> String
calcEsp xs
	| take 4 xs == "[esp" = "[esp+" ++ g (takeWhile (/= ']') (drop 4 xs)) ++ "],"
	| otherwise = xs
	where
		g [] = "32"
		g xs = show $ (read (tail xs) :: Int) + 32
